= The Hamcrest Tutorial for Python =

== Introduction ==

Hamcrest is a framework for writing matcher objects allowing 'match' rules to be defined declaratively. There are a number of situations where matchers are invaluble, such as UI validation, or data filtering, but it is in the area of writing flexible tests that matchers are most commonly used. This tutorial shows you how to use Hamcrest for unit testing.

When writing tests it is sometimes difficult to get the balance right between overspecifying the test (and making it brittle to changes), and not specifying enough (making the test less valuable since it continues to pass even when the thing being tested is broken). Having a tool that allows you to pick out precisely the aspect under test and describe the values it should have, to a controlled level of precision, helps greatly in writing tests that are "just right". Such tests fail when the behaviour of the aspect under test deviates from the expected behaviour, yet continue to pass when minor, unrelated changes to the behaviour are made.

== My first Hamcrest test ==

We'll start be writing a very simple PyUnit test, but instead of using PyUnit's `assertEqual` method, we use Hamcrest's `assert_that` construct and the standard set of matchers:

{{{
from hamcrest import *
import unittest

class BiscuitTest(unittest.TestCase):
    def testEquals(self):
        theBiscuit = Biscuit('Ginger')
        myBiscuit = Biscuit('Ginger')
        assert_that(theBiscuit, equalto(myBiscuit))

if __name__ == '__main__':
    unittest.main()
}}}

The `assert_that` function is a stylized sentence for making a test assertion. In this example, the subject of the assertion is the object `theBiscuit` that is the first method parameter. The second method parameter is a matcher for `Biscuit` objects, here a matcher that checks one object is equal to another using the Python `==` operator. The test passes since the `Biscuit` class defines an __eq__ method.

If you have more than one assertion in your test you can include an identifier for the tested value in the assertion:

{{{
assert_that(theBiscuit.getChocolateChipCount(), equalto(10), 'chocolate chips')
assert_that(theBiscuit.getHazelnutCount(), equalto(3), 'hazelnuts')
}}}

== A tour of common matchers ==

Hamcrest comes with a library of useful matchers. Here are some of the most important ones. 

  * Core
    * `anything` - always matches, useful if you don't care what the object under test is
    * `described_as` - decorator to adding custom failure description
    * `is_` - decorator to improve readability - see "Sugar", below
  * Logical
    * `allof` - matches if all matchers match, short circuits (like Python &&)
    * `anyof` - matches if any matchers match, short circuits (like Python ||)
    * `not_` - matches if the wrapped matcher doesn't match and vice versa
  * Object
    * `equalto` - test object equality using `==`
    * `hasstring` - test str(object) value
    * `instanceof` - test type
    * `none`, `not_none` - test for None
    * `sameinstance` - test object identity
  * Sequences
    * `hasentry`, `haskey`, `hasvalue` - test a dictionary contains an entry, key or value
    * `hasitem`, `hasitems` - test a sequence contains elements
  * Number
    * `closeto` - test numeric values are close to a given value
    * `greaterthan`, `greaterthan_or_equalto`, `lessthan`, `lessthan_or_equalto` - test ordering
  * Text
    * `equalto_ignoring_whitespace` - test string equality ignoring differences in runs of whitespace
    * `containsstring`, `endswith`, `startswith` - test string matching

== Sugar ==

Hamcrest strives to make your tests as readable as possible. For example, the `is_` matcher is a wrapper that doesn't add any extra behavior to the underlying matcher. The following assertions are all equivalent:

{{{
assert_that(theBiscuit, equalto(myBiscuit))
assert_that(theBiscuit, is_(equalto(myBiscuit)))
assert_that(theBiscuit, is_(myBiscuit))
}}}

The last form is allowed since `is_(value)` wraps non-matcher arguments with `equalto`.

== Writing custom matchers ==

Hamcrest comes bundled with lots of useful matchers, but you'll probably find that you need to create your own from time to time to fit your testing needs. This commonly occurs when you find a fragment of code that tests the same set of properties over and over again (and in different tests), and you want to bundle the fragment into a single assertion. By writing your own matcher you'll eliminate code duplication and make your tests more readable!

Let's write our own matcher for testing if a string is comprised of only digits. This is the test we want to write:

{{{
def testStringIsOnlyDigits(self):
    assert_that('17', is_(onlydigits()))
}
}}}

And here's the implementation:

{{{
from hamcrest.core.base_matcher import BaseMatcher
from hamcrest.core.internal.hasmethod import hasmethod

class IsStringOfDigits(BaseMatcher):

    def matches(self, item):
        if not hasmethod(item, 'isdigit'):
            return False
        return item.isdigit()

    def describe_to(self, description):
        description.append_text('string of digits')

onlydigits = IsStringOfDigits
}}}

For our Matcher implementation we implement the `matches` method - which calls the `isdigit` string method after confirming that the argument (which may not be a string) has such a method - and the `describe_to` method - which is used to produce a failure message when a test fails. Here's an example of how the failure message looks:

{{{
assert_that('17b', is_(onlydigits()))
}}}

fails with the message

{{{
AssertionError: 
Expected: is string of digits
     got: '17b'
}}}

The factory function `onlydigits` is defined as an alias because no further logic is needed, but other matchers may work best with an actual factory. We import `onlydigits` to use the matcher in our test:

{{{
from hamcrest import *
import unittest
from hamcrest_local.isstringofdigits import onlydigits

class StringTest(unittest.TestCase):
    def testStringIsOnlyDigits(self):
        assert_that('17', is_(onlydigits()))

if __name__ == '__main__':
    unittest.main()
}}}

Even though the `onlydigits` function creates a new matcher each time it is called, you should not assume this is the only usage pattern for your matcher. Therefore you should make sure your matcher is stateless, so a single instance can be reused between matches.